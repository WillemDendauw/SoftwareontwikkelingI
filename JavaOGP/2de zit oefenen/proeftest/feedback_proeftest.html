Hierbij wat feedback over de proeftest van Software-ontwikkeling.<br />Om niet misbegrepen te worden: NIET alle code is VOORBEELDcode. Er staat ook TEGENVOORBEELDcode: zo moet het NIET. Dus lees aandachtig de tekst die bij de code hoort.<h2>Klasse Krijger</h2><ol>	<li>Eerste opmerking: jullie kregen de klasse <code>Krijgers</code> (MET EEN &#39;s&#39; OP HET EINDE), en deze klasse bevatte de main-methode. Dan is het niet zo&#39;n goed idee om in DEZE klasse een Krijger te gaan defini&euml;ren. Maak daarvoor een nieuwe klasse aan, met naam <code>Krijger</code> (ZONDER &#39;s&#39; OP HET EINDE).</li>	<li>Gezien elke Krijger ofwel een Ninja, ofwel een Samoerai moet zijn, maak je de klasse Krijger abstract. Het heeft immers geen zin toe te laten dat er een object van de klasse Krijger wordt aangemaakt.</li>	<li>Je moet Krijgers kunnen vergelijken; dus implementeer je de methode <code>compareTo(Object o)</code>. Of je kiest ervoor om enkel de methode <code>compareTo(Krijger k)</code> te implementeren. In het eerste geval komt er dan bij de hoofding van de klasse <code>implements Comparable</code>, in het tweede geval <code>implements Comparable&lt;Krijger&gt;</code>.<br />	Merk op:	<ul>		<li>de tweede versie, die type-safe is, bestond voor JDK 1.5 niet. Tot JDK 1.4 was enkel de eerste optie mogelijk.</li>		<li>er is een verschil tussen <code>implements Comparable</code> en <code>implements Comparator</code>!!!</li>	</ul>	<p>Oplossing:</p>	<pre>    @Override    public int compareTo(Object o) {        return this.compareTo((Krijger) o);    }     public int compareTo(Krijger k){        ... // geen testen op null             // (API verwacht nullpointerException in plaats van een rangschikking)            // evenmin testen op klasse             // (API verwacht ClassCastException in plaats van een rangschikking)    }   </pre>	Indien de parameter <code>o</code> dan geen Krijger blijkt te zijn, zal er een exceptie opgeworpen worden. De Java API van de interface <code>Comparable&lt;T&gt;</code> geeft duidelijk aan welke excepties geworpen moeten worden; zie <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html#compareTo(T)">deze link</a>.	<p>In de unitTest kan je ook testen of de juiste excepties opgeworpen werden. Een mogelijke oplossing daarvan:</p>	<pre>    @Test     public void testCompareToObject() {        System.out.println(&quot;compareTo(Object)&quot;);        Krijger krijger = new Ninja(20,&quot;Ninja&quot;);        try {            krijger.compareTo(null);            fail(&quot;Moet NullPointerException gooien&quot;);        } catch (NullPointerException e) {            assertTrue(true);        }        try {            krijger.compareTo(new Object());            fail(&quot;Moet ClassCastException gooien&quot;);        } catch (ClassCastException e) {            assertTrue(true);        }    }</pre>	Of, je kan de test in stukjes knippen, en aangeven in de hoofding van de testmethode dat er een exceptie verwacht wordt (en welke).	<pre>    @Test(expected = NullPointerException.class)    public void testNullptrs() {        System.out.println(&quot;compareTo(Object)&quot;);        Krijger krijger = new Ninja(20,&quot;Ninja&quot;);              krijger.compareTo(null);    }</pre>	</li>	<li>Let op effici&euml;ntie. De code die hieronder staat, doorloopt sowieso x, ook als getal!=0. Tijdverlies. (Voor de computer. Maar ook een beetje voor de lezer, die zich afvraagt welke constructie (en waarom) daar bovengehaald wordt.)	<pre>        @Override                                                                // INEFFICIENTE CODE    public int compareTo(Object o){                                          // INEFFICIENTE CODE        Krijger k = (Krijger) o;                                             // INEFFICIENTE CODE        int getal = naam.compareTo(k.getNaam());  // hier bereken je &#39;getal&#39; // INEFFICIENTE CODE        int x = 0;                                // hier bereken je &#39;x&#39;     // INEFFICIENTE CODE        if(this.levend() &amp;&amp; k.levend()){                                     // INEFFICIENTE CODE            x = 0;                                                           // INEFFICIENTE CODE        } else if (this.levend()){                                           // INEFFICIENTE CODE            x = -1;                                                          // INEFFICIENTE CODE        } else if(k.levend()){                                               // INEFFICIENTE CODE             x = 1;                                                           // INEFFICIENTE CODE        }                                                                    // INEFFICIENTE CODE         if(getal==0){ // hier beslis je dat je &#39;x&#39; misschien helemaal niet   // INEFFICIENTE CODE            return x; // nodig hebt...                                       // INEFFICIENTE CODE        } else {                                                             // INEFFICIENTE CODE            return getal;                                                    // INEFFICIENTE CODE        }                                                                    // INEFFICIENTE CODE    }</pre>	</li>	<li>Let op! De test <code>if(this==null)</code> is hier NIET op zijn plaats! Uiteraard kan het huidige object niet null zijn, want dan zou je de huidige methode niet kunnen oproepen. Totaal overbodige test, dus.</li>	<li>In de opgave stond duidelijk &#39;verdedigings-/aanvalskrachten worden telkens opnieuw berekend&#39;. Dan is het expliciet een slecht idee om deze gegevens als instantievariabele bij te houden. Niet in de bovenklasse Krijger, niet in de afgeleide klassen Ninja of Samoerai! Herberekenen is herberekenen, en niet ergens opslaan. En uiteraard heeft het geen zin om deze krachten ergens in de constructor te herberekenen. Ten eerste heeft niemand ze daar nodig (je mag ze toch niet opslaan), en ten tweede veranderen ze toch tijdens de &#39;levensloop&#39; van het object.</li>	<li>Een afgeleide klasse kan niet aan de instantievariabelen van de bovenklasse, tenzij die <code>protected</code> in plaats van <code>private</code> gedeclareerd zijn. Doe dat dan: maak de nodige instantievariabelen protected in de bovenklasse. Wat uiteraard helemaal not done is: diezelfde instantievariabelen nogmaals declareren in de afgeleide klasse.</li>	<li>Als &eacute;&eacute;n van de methodes in een klasse een randomgenerator nodig heeft, mag je die als instantievariabele declareren en meteen initialiseren. Stel dit niet uit tot in de methode zelf, want dan maak je telkens nieuwe generatoren aan per getal dat je random moet genereren.</li>	<li>Houd je code overzichtelijk. Vergelijk hieronder leesbaarheid en lengte.	<pre>    public boolean isAlive() {         // NIET ERG PROPERE CODE        boolean levend = true;         // NIET ERG PROPERE CODE        if (this.getLevens() &lt;= 0) {   // NIET ERG PROPERE CODE            levend = false;            // NIET ERG PROPERE CODE        }                              // NIET ERG PROPERE CODE        return levend;                 // NIET ERG PROPERE CODE    }	    public boolean isAlive(){          // NETJES OPGEKUIST        return aantalLevens &gt; 0;       // NETJES OPGEKUIST     }	    </pre>	Heb je ook gemerkt dat het gebruik van de getter <code>.getLevens()</code> overbodig is? Omdat de methode <code>isAlive</code> tot dezelfde klasse behoort als de instantievariabele <code>aantalLevens</code>.</li>	<li>Het is niet de bedoeling dat je naar lieverlee een heleboel extra getters (oei), setters (foei) en constructoren bijmaakt. Houd je aan de opgave, zodat je op tijd aan de volgende klassen kan beginnen - en daar kan bewijzen dat je het OOK ZONDER die extra setters/constructoren kan. Een voorbeeld ter illustratie:	<pre>public class Krijgers {    String naam;    int levens,gewonnen,aKracht,vKracht; // teveel!        public Krijgers(String naam, int levens, int gewonnen, int aKracht, int vKracht){...} // niet gevraagd!	    public Krijgers(String naam, int levens, int gewonnen){...} // niet gevraagd!    public boolean isLevend(){...}     // ok     public String isLevendString{...}  // niet gevraagd          public int getAantalLevens(){...}  // ok            public void setAantalLevens(){...} // niet gevraagd    public String getNaam(){...}       // ok            public void incGewonnen(){...}            // ok, maar naamgeving kon beter    public void decGewonnen(){...}            // niet gevraagd        public void incLevens(){...}              // niet gevraagd    public void decLevens(){...}              // ok, maar naamgeving kon beter    public int getAanvalsKracht(){...}        // ok - mits BEREKEND    public void setAanvalsKracht(){...}       // niet gevraagd    public int getVerdedigingsKracht(){...}   // ok - mits BEREKEND    public void setVerdedigingsKracht(){...}  // niet gevraagd    public int getGewonnen(){...}             // ok    public boolean isGewonnen(Boolean b){...} // niet gevraagd       public void setGewonnen(int gewonnen){...}// niet gevraagd    public void gevechtMet(Krijger){...}      // niet gevraagd    @Override public int hashCode(){...}      // niet gevraagd, maar is je vergeven    @Override public boolean equals(Object obj){...} // idem      </pre>	</li>	<li>Nog een tip om tijd te besparen: het is edelmoedig om alle mogelijke verkeerde input op te proberen vangen. Maar doorgaans verlies je daarmee de belangrijke zaken uit het oog - en je tijd. Ook hier een voorbeeld:	<pre>    public Krijger(String naam, int levens) {                                        // ok        this.naam = new String(naam);                                                // ok        if( levens &lt; 0){                                                             // niet doen            throw new RuntimeException(&quot;Krijger levens kunnen niet negatief zijn!&quot;); // niet doen        }                                                                            // niet doen        this.levens = levens;                                                        // ok      }</pre>	(Ja, het is properder en veiliger. Maar je moet keuzes maken als je een test aflegt... en dan laat je misschien beter zien dat je tot het einde van de opgave raakt, voor je dergelijke extra&#39;s inbouwt.)	<h2>Testklasse</h2>	</li>	<li>Deze test heeft niet zoveel zin: <code>assertEQuals(3,4,0.0001)</code>. Want dan ga je na of de twee GEHELE getallen 3 en 4 al dan niet gelijk zijn, op een fractie na. Als je het zo ziet staan is het logisch, maar hier is het al wat subtieler - doch even fout:	<pre>    double EPS=0.00001;    assertEquals(1,k.getGewonnenGevechten(),EPS);</pre>	</li>	<li>Gegeven onderstaande testcode. De methodes <code>getAanvalskracht()</code> en <code>getVerdedigingskracht()</code> zouden een getal binnen bepaalde grenzen moeten genereren. In deze test wordt dat gecontroleerd. Welke redeneerfout werd er gemaakt?	<pre>        @Test    public void TestAanvalVerdediging(){        Assert.assertTrue(n.getAanvalskracht()&gt;=0 &amp;&amp; n.getAanvalskracht()&lt;450);        Assert.assertTrue(n.getVerdedigingskracht()&gt;=0 &amp;&amp; n.getVerdedigingskracht()&lt;480);        Assert.assertTrue(s.getAanvalskracht()&gt;=0 &amp;&amp; s.getAanvalskracht()&lt;164);        Assert.assertTrue(s.getVerdedigingskracht()&gt;=0 &amp;&amp; s.getVerdedigingskracht()&lt;200);    }</pre>	Antwoord: het heeft weinig zin om te testen of random-gegenereerde getallen inderdaad binnen de onderstelde grenzen liggen. Er is immers veel kans dat, &oacute;&oacute;k indien je de grenzen per ongeluk verkeerd instelde, dat &eacute;ne geval dat je hier test, toch binnen de verhoopte grenzen blijft. Beter idee: laat deze test zo dikwijls lopen, dat er statistisch gezien een grote kans is dat je het hele bereik bestreken hebt. Dus zet de test in een <code>for(int i=0; i&lt;100000000; i++)</code>-lus.	<p>Toegespitst op de context waarin deze code geschreven werd: er waren testen die voorrang verdienden, bijvoorbeeld de test of <code>compareTo</code> in orde was.</p>	<h2>KrijgerVergelijker</h2>	</li>	<li>Deze klasse hebben we nodig omdat we, NAAST de &#39;natuurlijke&#39; sorteermethode die we in de klasse <code>Krijger</code> zelf al implementeerden, een bijkomende sorteermethode willen hebben. Hoofding van deze klasse:	<pre>public class KrijgerComp implements Comparator<krijger> { </krijger></pre>	Ook hier kan je kiezen voor <code>implements Comparator</code> (ook voor vergelijking met niet-Krijgers) dan wel <code>implements Comparator&lt;Krijger&gt;</code>. Je editeeromgeving wijst je dan verder de weg voor de hoofding van de methode <code>compare(...,...)</code> die je moet overloaden.	<p>Raadpleeg ook hier de <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#compare(T,%20T,%20java.util.Comparator)">API</a> (en merk op dat er voor <code>null</code> keuze gelaten wordt).</p>	</li>	<li>Merk op: bij het implementeren van de methode <code>compare(Krijger,Krijger)</code> uit de klasse <code>KrijgerVergelijker</code>, kan je aan de protected instantievariabelen van de klasse <code>Krijger</code>. Je hoeft dus niet via methodes van <code>Krijger</code> te gaan als je de info ook rechtstreeks uit de instantievariabelen kan halen. Dit komt omdat beide klassen (<code>KrijgerVergelijker</code> en <code>Krijger</code>) in dezelfde package staan. (Merk op: in <code>C#</code> zou dit niet het geval zijn. Zie cursus Softwareontwikkeling II.)	<h2>DAODummy</h2>	</li>	<li>De bestaansreden van een Dummyklasse: je zorgt dat je hier een aantal (hardgecodeerde) objecten hebt klaarstaan, waarop je dan testen kan uitvoeren. Je plaatst de hardgecodeerde namen dus ook binnen die klasse; mag gerust als klassevariabelen (<code>static</code>) en niet wijzigbaar (<code>final</code>).	<pre>public class DAODummy ...{    private final String[] namen = {&quot;Donatello&quot;, &quot;Mich&quot;, &quot;Raf&quot;, &quot;Schreder&quot;, &quot;Bruce&quot;, &quot;Arnold&quot;};    private final int[] gewonnen = {2, 3, 2, 3, 3, 3};    private final int[] levens = {2, 4, 2, 0, 3, 3};    ...}</pre>	</li>	<li>Een tussendoortje. Toon aan dat, met enkele minieme ingrepen, het drie keer zo kort (&eacute;n drie keer zo leesbaar) kan. (Voor de rest geen uitspraken over de juistheid. Tenzij dit: er werd een setter gebruikt die verondersteld werd niet te bestaan.)	<pre>    public KrijgerDAODummy() {                                                // NIET GOED        int i=0;                                                              // NIET GOED        int a;                                                                // NIET GOED        Ninja nj;                                                             // NIET GOED        lijst = new ArrayList();                                              // NIET GOED          String naam;                                                          // NIET GOED        int leven;                                                            // NIET GOED        int gewonnenDuel;                                                     // NIET GOED         while(i&lt;6){                                                           // NIET GOED            naam = namen[i];                                                  // NIET GOED              leven = levens[i];                                                // NIET GOED            gewonnenDuel = gewonnen[i];                                       // NIET GOED            nj = new Ninja(naam, leven);                                      // NIET GOED             nj.setAantalGewonnen(gewonnenDuel);                               // NIET GOED            lijst.add(nj);                                                    // NIET GOED             i++;                                                              // NIET GOED //            System.out.println(nj.getNaam()+ &quot; aantal gewonnen: &quot;           // NIET GOED  //            +nj.getAantalGewonnen() + &quot; aantal levens: &quot; + nj.getLevens()); // NIET GOED            }    }</pre>	<h2>KrijgersDAO</h2>	</li>	<li>De klasse <code>KrijgersDAO</code> is de klasse die verschillende krijgers tegelijk beheert, en sorteert op verschillende manieren.<br />	Belangrijk: gevraagd werd de klasse <code>abstract</code> te maken. Uiteindelijk moet de klasse drie dingen kunnen: krijgers in oorspronkelijke volgorde uitschrijven, in natuurlijke volgorde, in speciale volgorde.<br />	HOE de krijgers bewaard worden (in een set, list, array,...) ligt niet vast in deze klasse. Deze klasse heeft dus geen instantievariabelen. De afgeleide klasse (DAODummy) heeft dat wel - daar had je trouwens al besloten (hopelijk...) dat een array of list als instantievariabele de enige juiste keuze was. (Bewaar je de krijgers meteen in een set, dan is hun oorspronkelijke volgorde verloren.)<br />	We verkrijgen dus:	<pre>public abstract class KrijgerDAO {                                               // OK    public abstract Krijger[] getKrijgers();                                     // OK    // dit VOORAL NIET HIER IMPLEMENTEREN, zodat je echt een abstracte    // klasse hebt! (Je KAN het trouwens niet implementeren, omdat je geen    // instantievariabelen hebt.)        public SortedSet&lt;Krijger&gt; getKrijgersGesorteerd(){...}                    // OK    // deze methode IMPLEMENTEER JE WEL hier:    // omdat je getKrijgers() kan oproepen, heb je de array met alle krijgers.    // Deze array steek je in een SortedSet, en het sorteren gebeurt automatisch.            public SortedSet&lt;Krijger&gt; getKrijgersGesorteerdSpeciaal(){...}            // OK    // idem}</pre>	</li>	<li>Het is niet omdat een klasse abstract is, dat je implementatie van ALLE methodes MOET uitstellen tot in de afgeleide klassen. Hieronder staat wat code, met een vraag bij geformuleerd.	<pre>public abstract class KrijgersDAO {        public SortedSet&lt;Krijgers&gt; getKrijgers(){                   // NIET OK, moet abstract zijn        return null;    }    public SortedSet&lt;Krijgers&gt; getKrijgersAlfa(){               // OK mits implementatie          return null;    }    public SortedSet&lt;Krijgers&gt; getKrijgersComp(){               // OK mits implementatie        return null;    }//    Dit is volgens mij raar dat er hier moet gereturnd worden. //    Dit is een abstracte klasse dus de body&#39;s moeten niet gedeclareerd worden.}</pre>	Het antwoord op de vraag: de methode <code>getKrijgers()</code> maak je abstract, omdat je ze niet k&aacute;n implementeren zolang je niet weet hoe de afgeleide klasse de Krijgers bewaart (in een list of een array of nog anders). De andere twee methodes laat je niet-abstract (zoals ze er nu staan) en je implementeert ze onmiddellijk - je kan de methode <code>getKrijgers()</code> gebruiken om aan de (niet-gesorteerde) collectie krijgers te geraken.</li>	<li>Hieronder wat code die we in vorige studentenversies tegenkwamen, met commentaar.	<pre>(1)    ArrayList&lt;Krijger&gt; a = returnKrijgers();    // ok    a.sort((Comparator)new KrijgerVergelijker());  // niet goed    Collections.sort(a,new KrijgerVergelijker());  // wel goed    (2)        Krijgers[] krrr= krr.clone(); // waarom klonen?                // allicht omdat je beseft dat de sort hieronder ervoor zorgt                // dat je de krijgers niet meer in oorspronkelijke volgorde hebt     sort(krrr); // waarom sorteer je de array? dat gebeurt automatisch bij objecten                 // toevoegen aan TreeSet.                 // Dus was het klonen ook niet nodig.    TreeSet <krijgers>set=new TreeSet();    set.addAll(Arrays.asList(krr));    return set;    </krijgers></pre>	</li>	<li>Merk op: als je start met 10 krijgers, en je vraagt aan de klasse <code>DAO</code> om deze op drie verschillende manieren uit te schrijven, dan heb je nog altijd maar 10 objecten van de klasse Krijger, en GEEN 30! Enkel de verwijzingen naar 10 bestaande objecten worden &#39;ontdubbeld&#39;: er zijn 10 verwijzingen die in een array zitten en de oorspronkelijke volgorde onthouden, er zijn 10 verwijzingen die in een SortedSet zitten en diezelfde 10 objecten aanwijzen in natuurlijke volgorde, en analoog voor de laatste SortedSet. Dit zou in C++ (gegeven dat je OBJECTEN bewaart in de containers, en geen pointers...) wel even anders zijn!	<p>Je mag de implementatie echter NIET uitwerken zoals in onderstaande code, maar je moet wel degelijk een nieuwe set (of collectie) opbouwen aan de hand van een andere.</p>	<pre>    public List geefKrijgers(){                              return krijgers;    }        public List geefKrijgersInNatuurlijkeVolgorde(){ // FOUT        Collections.sort(krijgers);                  // FOUT         return krijgers;                             // FOUT    }</pre>	</li>	<li>Er werd uitdrukkelijk gevraagd om de methode(s) <code>getKrijgersGesorteerd()</code> een <code>SortedSet</code> te laten teruggeven. De declaratie van je variabele gebruikt de <code>SortedSet</code> (de interface), de initialisatie gebruikt <code>TreeSet</code> (de klasse die de interface implementeert).	<pre>    public SortedSet&lt;Krijger&gt; getCustomGesorteerdeKrijgers(){                SortedSet&lt;Krijger&gt; ts = new TreeSet&lt;&gt;(new KrijgerVergelijker());        // mag ook:        // TreeSet&lt;Krijger&gt; ts = new TreeSet&lt;&gt;(new KrijgerVergelijker());        ts.addAll(krijgers);        return ts;    }</pre>	<h2>Main</h2>	</li>	<li>In de gegeven klasse <code>Krijgers</code> stond de main-methode al klaar. Je moet drie keer iets uitprinten: een list of een array, en twee keer een sorted set. Uiteraard vermijd je duplicated code door een print-methode te schrijven. Deze moet dan zowel een list en/of array als een set aanvaarden als parameter. Gebruik daarvoor <code>Iterable</code>.</li></ol>